#!/bin/bash

OUTPUT_FILE="output.txt"
: > "$OUTPUT_FILE" # Truncate the file at the beginning
exec 3>&1 1>"$OUTPUT_FILE" 2>&1
start_time=$(date +%s)
echo "[INFO] Starting initialization..." >&3
date >&3

# Highlight key phrases
highlight_special_phrases() {
    sed -E \
        -e 's/(no such file or directory)/\033[0;33m\1\033[0m/Ig' \
        -e 's/(does not exist|doesn.t exist)/\033[0;31m\1\033[0m/Ig' \
        -e 's/(memory)/\033[0;35m\1\033[0m/Ig'
}

# Collect all log files while showing live count
log_files=()
echo "[INFO] Collecting log files..." >&3
subdirs=( $(find . -type d -print0 | xargs -0) )
for dir in "${subdirs[@]}"; do
  echo "  - Scanning directory: $dir" >&3
  for logfile in "$dir"/*.log; do
    [[ -f "$logfile" ]] && log_files+=("$logfile")
  done
done
echo "[INFO] Log file discovery complete." >&3
date >&3

# Show progress bar
show_progress() {
    local progress=$(( 100 * count / total ))
    local bar_width=50
    local filled=$(( progress * bar_width / 100 ))
    local bar=$(printf "%${filled}s" | tr ' ' '#')
    bar=$(printf "%-${bar_width}s" "$bar")
    printf "Processing [%s]: %3d%% (%d/%d)\r" "$bar" "$progress" "$count" "$total" >&3
}

# Process individual log file
process_logfile() {
    local logfile="$1"
    local dir
    dir=$(dirname "$logfile")

    error_tmp=$(mktemp)
    fail_tmp=$(mktemp)

    # Match 'error' not followed by ';'
    awk '{IGNORECASE=1} /error/ && $0 !~ /error *;/ {print}' "$logfile" > "$error_tmp"

    # Match 'fail'
    grep -i 'fail' "$logfile" > "$fail_tmp"

    if [[ -s "$error_tmp" || -s "$fail_tmp" ]]; then
        echo -e "\nIn directory: $dir" >&3
        echo "  Log file: $logfile" >&3

        if [[ -s "$error_tmp" ]]; then
            echo "  Matches for 'error':" >&3
            GREP_COLOR='1;32' grep --color=always -i 'error' "$error_tmp" | highlight_special_phrases >&3
        fi

        if [[ -s "$fail_tmp" ]]; then
            echo "  Matches for 'fail':" >&3
            GREP_COLOR='1;33' grep --color=always -i 'fail' "$fail_tmp" | highlight_special_phrases >&3
        fi
    fi

    rm -f "$error_tmp" "$fail_tmp"
}

# Process all log files with progress
echo "[INFO] Starting log file analysis..." >&3
date >&3

total=${#log_files[@]}
count=0
for logfile in "${log_files[@]}"; do
    ((count++))
    show_progress
    process_logfile "$logfile"
done

# Final message
end_time=$(date +%s)
echo -e "\n[INFO] Done. Output saved to $OUTPUT_FILE" >&3
echo "[INFO] Finished at: $(date)" >&3
echo "[INFO] Total duration: $((end_time - start_time)) seconds" >&3