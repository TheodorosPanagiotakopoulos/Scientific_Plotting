#!/bin/bash

OUTPUT_FILE="output.txt"
> "$OUTPUT_FILE"  # Clear output file

exec 3>&1  # Save original stdout (terminal) to FD 3
exec > "$OUTPUT_FILE" 2>&1  # Redirect all stdout and stderr to file

# Highlight key phrases:
highlight_special_phrases() {
    sed -E "
        s/(no such file or directory)/$(printf '\033[1;31m')\1$(printf '\033[0m')/Ig;
        s/(does not exist)/$(printf '\033[1;31m')\1$(printf '\033[0m')/Ig;
        s/(doesn[â€™']t exist)/$(printf '\033[1;31m')\1$(printf '\033[0m')/Ig;
        s/(memory)/$(printf '\033[1;35m')\1$(printf '\033[0m')/Ig
    "
}

# Show log count message (overwrites itself)
show_log_count() {
    local count="$1"
    local plural="file"
    (( count != 1 )) && plural="files"
    printf "\rFound %d .log %s" "$count" "$plural" >&3
}

# Progress bar
show_progress() {
    local progress=$(( 100 * count / total ))
    local bar_width=50
    local filled=$(( progress * bar_width / 100 ))
    local bar=$(printf "%${filled}s" | tr ' ' '#')
    bar=$(printf "%-${bar_width}s" "$bar")
    printf "\rProcessing: [%s] %3d%% (%d/%d)" "$bar" "$progress" "$count" "$total" >&3
}

# Process a single directory
process_directory() {
    local dir="$1"
    shopt -s nullglob
    log_files=("$dir"/*.log)
    local log_count=${#log_files[@]}

    show_log_count "$log_count"

    for logfile in "${log_files[@]}"; do
        error_tmp=$(mktemp)
        fail_tmp=$(mktemp)

        awk '{IGNORECASE=1} /error/ && $0 !~ /error *;/ {print}' "$logfile" > "$error_tmp"
        grep -i 'fail' "$logfile" > "$fail_tmp"

        if [[ -s "$error_tmp" || -s "$fail_tmp" ]]; then
            echo "In directory: $dir"
            echo "  Log file: $logfile"

            if [[ -s "$error_tmp" ]]; then
                echo "    Matches for 'error':"
                GREP_COLOR='1;32' grep --color=always -i 'error' "$error_tmp" | highlight_special_phrases
            fi

            if [[ -s "$fail_tmp" ]]; then
                echo "    Matches for 'fail':"
                GREP_COLOR='1;33' grep --color=always -i 'fail' "$fail_tmp" | highlight_special_phrases
            fi

            echo
        fi

        rm -f "$error_tmp" "$fail_tmp"
    done
}

# Get all directories, including current
mapfile -d '' subdirs < <(find . -type d -print0)
total=${#subdirs[@]}
count=0

# Initial message
echo "Starting processing..." >&3

# Process each directory
for subdir in "${subdirs[@]}"; do
    ((count++))
    process_directory "$subdir"
    show_progress
done

# Final newline and message
echo -e "\nDone. Output saved to $OUTPUT_FILE" >&3