#!/bin/bash

OUTPUT_FILE="output.txt"
: > "$OUTPUT_FILE"
exec 3>&1 1>"$OUTPUT_FILE" 2>&1

# Step 1: One-time message
echo "Looking for .log files" >&3
sleep 0.3

# Step 2: Real-time log file counting with final confirmation
log_files=()
log_count=0
printf "0.log files found" >&3  # Initial display

subdirs=( $(find . -type d -print0 | xargs -0) )
for dir in "${subdirs[@]}"; do
    for logfile in "$dir"/*.log; do
        [[ -f "$logfile" ]] || continue
        log_files+=("$logfile")
        ((log_count++))
        printf "\r%d.log files found" "$log_count" >&3
    done
done

# Final confirmation after discovery (printed on a new line)
echo -e "\n$log_count.log files found" >&3

# Step 3: Progress bar
show_progress() {
    local progress=$(( 100 * count / total ))
    local bar_width=50
    local filled=$(( progress * bar_width / 100 ))
    local bar=$(printf "%${filled}s" | tr ' ' '#')
    bar=$(printf "%-${bar_width}s" "$bar")
    printf "\rProcessing [%s]: %3d%% (%d/%d)" "$bar" "$progress" "$count" "$total" >&3
}

# Step 4: Silent log file processing
process_logfile() {
    local logfile="$1"
    local dir
    dir=$(dirname "$logfile")

    error_tmp=$(mktemp)
    fail_tmp=$(mktemp)

    awk '{IGNORECASE=1} /error/ && $0 !~ /error *;/ {print}' "$logfile" > "$error_tmp"
    grep -i 'fail' "$logfile" > "$fail_tmp"

    if [[ -s "$error_tmp" || -s "$fail_tmp" ]]; then
        {
            echo -e "\nIn directory: $dir"
            echo "  Log file: $logfile"

            if [[ -s "$error_tmp" ]]; then
                echo "  Matches for 'error':"
                grep -i 'error' "$error_tmp"
            fi

            if [[ -s "$fail_tmp" ]]; then
                echo "  Matches for 'fail':"
                grep -i 'fail' "$fail_tmp"
            fi
        } >> "$OUTPUT_FILE"
    fi

    rm -f "$error_tmp" "$fail_tmp"
}

# Step 5: Process logs with progress bar
total=${#log_files[@]}
count=0
for logfile in "${log_files[@]}"; do
    ((count++))
    show_progress
    process_logfile "$logfile"
done

# Final status
echo -e "\nDone. Output saved to $OUTPUT_FILE" >&3


------------

#!/bin/bash

OUTPUT_FILE="output.txt"
: > "$OUTPUT_FILE"
exec 3>&1 1>"$OUTPUT_FILE" 2>&1

# Print one-time message
echo "Looking for .log files" >&3
sleep 0.3

# Real-time log file discovery
log_files=()
log_count=0
printf "0.log files found" >&3

subdirs=( $(find . -type d -print0 | xargs -0) )
for dir in "${subdirs[@]}"; do
    for logfile in "$dir"/*.log; do
        [[ -f "$logfile" ]] || continue
        log_files+=("$logfile")
        ((log_count++))
        printf "\r%d.log files found" "$log_count" >&3
    done
done

# Final confirmation (print once, new line)
echo -e "\n$log_count.log files found" >&3

# Highlight function for color in output.txt
highlight_special_phrases() {
    sed -E \
        -e 's/(no such file or directory)/\\x1b[0;31m\\1\\x1b[0m/Ig' \
        -e 's/(memory)/\\x1b[0;31m\\1\\x1b[0m/Ig'
}

# Progress bar display
show_progress() {
    local progress=$(( 100 * count / total ))
    local bar_width=50
    local filled=$(( progress * bar_width / 100 ))
    local bar=$(printf "%${filled}s" | tr ' ' '#')
    bar=$(printf "%-${bar_width}s" "$bar")
    printf "\rProcessing [%s]: %3d%% (%d/%d)" "$bar" "$progress" "$count" "$total" >&3
}

# Process each log file, output to file with color
process_logfile() {
    local logfile="$1"
    local dir
    dir=$(dirname "$logfile")

    error_tmp=$(mktemp)
    fail_tmp=$(mktemp)

    awk '{IGNORECASE=1} /error/ && $0 !~ /error *;/ {print}' "$logfile" > "$error_tmp"
    grep -i 'fail' "$logfile" > "$fail_tmp"

    if [[ -s "$error_tmp" || -s "$fail_tmp" ]]; then
        {
            echo -e "\\nIn directory: $dir"
            echo "  Log file: $logfile"

            if [[ -s "$error_tmp" ]]; then
                echo "  Matches for 'error':"
                GREP_COLOR='0;32' grep --color=always -i 'error' "$error_tmp" | highlight_special_phrases
            fi

            if [[ -s "$fail_tmp" ]]; then
                echo "  Matches for 'fail':"
                GREP_COLOR='0;33' grep --color=always -i 'fail' "$fail_tmp" | highlight_special_phrases
            fi
        } >> "$OUTPUT_FILE"
    fi

    rm -f "$error_tmp" "$fail_tmp"
}

# Run processing with progress bar
total=${#log_files[@]}
count=0
for logfile in "${log_files[@]}"; do
    ((count++))
    show_progress
    process_logfile "$logfile"
done

# Final message
echo -e "\\nDone. Output saved to $OUTPUT_FILE" >&3